/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import {
  CacheFirst,
  NetworkFirst,
  StaleWhileRevalidate,
} from "workbox-strategies";
import { ExpirationPlugin } from "workbox-expiration";

import { sendPostMessage, syncEvent } from "./lib/sync";
import { NotificationPayload } from "./lib/types";
import { POST_MESSAGES } from "./lib/constants";

declare const self: ServiceWorkerGlobalScope;

// Precache manifest generated by Vite PWA plugin
const precacheManifest = self.__WB_MANIFEST;

// Precache all assets in the manifest
precacheAndRoute(precacheManifest);

// Clean up outdated caches on service worker activation
cleanupOutdatedCaches();

// Cache Google Fonts CSS files
registerRoute(
  ({ url }) =>
    url.origin === "https://fonts.googleapis.com" &&
    url.pathname.startsWith("/css2"),
  new CacheFirst({
    cacheName: "google-fonts-css",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10, // Cache a limited number of Google Fonts CSS files
        maxAgeSeconds: 60 * 60 * 24 * 365, // Cache for 1 year
      }),
    ],
  })
);

// Cache font files served from Google Fonts
registerRoute(
  ({ url }) =>
    url.origin === "https://fonts.gstatic.com" &&
    /\.(woff2?|eot|ttf|otf)$/.test(url.pathname), // Match font file types (woff2, eot, ttf, otf)
  new CacheFirst({
    cacheName: "google-fonts-files",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20, // Cache a limited number of font files
        maxAgeSeconds: 60 * 60 * 24 * 365, // Cache for 1 year
      }),
    ],
  })
);

// Define cache names for assets and API responses
const ASSETS_CACHE = "assets-cache";
const API_CACHE = "api-cache";

// Cache static assets like JS, CSS, Fonts, and Images
registerRoute(
  ({ url }) =>
    /\.(?:js|css|woff2?|eot|ttf|svg|png|jpg|jpeg|gif)$/.test(url.pathname),
  new CacheFirst({
    cacheName: ASSETS_CACHE,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50, // Max number of assets to cache
        maxAgeSeconds: 60 * 60 * 24 * 30, // Cache for 30 days
      }),
    ],
  })
);

// Cache API requests using NetworkFirst strategy
registerRoute(
  /\/api\//,
  new NetworkFirst({
    cacheName: API_CACHE,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20, // Max number of API responses to cache
        maxAgeSeconds: 60 * 60, // Cache API responses for 1 hour
      }),
    ],
  })
);

// Cache dynamic content with StaleWhileRevalidate strategy
registerRoute(
  ({ url }) => /\/dynamic\//.test(url.pathname),
  new StaleWhileRevalidate({
    cacheName: "dynamic-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100, // Max number of dynamic resources to cache
        maxAgeSeconds: 60 * 60 * 24, // Cache for 1 day
      }),
    ],
  })
);

// Background sync with the `sync` event
self.addEventListener("sync", (event: any) => {
  syncEvent(event);
});

// Push event listener
self.addEventListener("push", (event: PushEvent) => {
  let payload = {} as NotificationPayload;
  if (event.data) {
    payload = event.data.json();
  }

  const title = payload.title || "New Notification";
  const options = {
    body: payload.body || "You have a new notification!",
    icon: payload.icon || "pwa-192x192.png",
    badge: payload.badge || "pwa-192x192.png",
    sound: "notification.mp3",
    data: {
      url: payload.url || "/",
    },
  };

  event.waitUntil(self.registration.showNotification(title, options));
  sendPostMessage(POST_MESSAGES.NOTIFICATION_RECEIVED);
});

// Notification click event listener
self.addEventListener("notificationclick", async (event: NotificationEvent) => {
  event.notification.close();

  // Check if there is a URL in the notification data
  const notificationUrl = event.notification.data?.url;

  if (notificationUrl && notificationUrl !== "/") {
    try {
      const clientsList = await self.clients.matchAll({
        type: "window",
        includeUncontrolled: true,
      });

      // Check if a client with the URL is already open
      for (const client of clientsList) {
        if (client.url === notificationUrl) {
          if (!client.focused) {
            await client.focus();
          }
          return;
        }
      }

      // If no matching client is found, open a new window with the URL
      await self.clients.openWindow(notificationUrl);
    } catch (error) {
      console.error("Failed to handle notification click with URL:", error);
    }
  } else {
    // If there is no URL, focus an existing client or open the default page
    try {
      const clientsList = await self.clients.matchAll({
        type: "window",
        includeUncontrolled: true,
      });

      for (const client of clientsList) {
        if (client.url === "/" && client.focused) {
          return;
        }
        client.focus();
      }

      // If no clients are focused or found, open a default page
      if (clientsList.length === 0) {
        await self.clients.openWindow("/");
      }
    } catch (error) {
      console.error("Failed to handle notification click without URL:", error);
    }
  }
});

// Activate event: Clean up old caches and claim control immediately
self.addEventListener("activate", (event: ExtendableEvent) => {
  event.waitUntil(
    Promise.all([
      self.clients.claim(),
      caches.keys().then((cacheNames) =>
        Promise.all(
          cacheNames.map((cacheName) => {
            if (![ASSETS_CACHE, API_CACHE].includes(cacheName)) {
              return caches.delete(cacheName);
            }
          })
        )
      ),
    ])
  );
});

// Install event: Ensure the service worker takes control immediately
self.addEventListener("install", (event: ExtendableEvent) => {
  event.waitUntil(self.skipWaiting());
});
